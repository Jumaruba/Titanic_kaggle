from deap import creator
from deap import base
from deap import gp
from deap import tools
from deap import algorithms
import string
import random
import pandas as pd
import numpy as np
import operator as op
import math

train = pd.read_csv("./data/train.csv")
test = pd.read_csv("./data/test.csv")

HOWMANYITERS = 10


def protectedDiv(left, right):
    try:
        return left / right
    except ZeroDivisionError:
        return 1


def randomString(stringLength=10):
    alphabet = string.ascii_lowercase
    return ''.join([random.choice(alphabet) for _ in range(stringLength)])


# the arity is the number of entries it will take
pset = gp.PrimitiveSet("MAIN", len(train.columns))
# adding statistics to it. The second argument is the number of input it takes
pset.addPrimitive(op.add, 2)
pset.addPrimitive(op.sub, 2)
pset.addPrimitive(op.mul, 2)
pset.addPrimitive(protectedDiv, 2)
pset.addPrimitive(op.neg, 1)
pset.addPrimitive(math.cos, 1)
pset.addPrimitive(math.sin, 1)
pset.addPrimitive(max, 2)
pset.addPrimitive(min, 2)
# there is no need to rename arguments since it's named by default
# ephemeral is basically which value is set when the object is created
pset.addEphemeralConstant(randomString(), lambda: random.uniform(-10, 10))

# fitness class to measure the fitting
creator.create("FitnessMin", base.Fitness, weights=(-1.0))
# class with the individue
creator.create("Individual", gp.PrimitiveTree, fitness=creator.FitnessMin)

# register parameters for the process
toolbox = base.Toolbox()
toolbox.register("expr", gp.genHalfAndHalf, pset=pset, min_=1, max_=3)
# creating a individual with values generated by expr
toolbox.register("individual", tools.initIterate, creator.Individual, toolbox.expr)
# creating a list (population) with individuals
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("compile", gp.compile, pset=pset)

outputs = train['Survived'].values.tolist()
drop = ['PassengerId', 'Survived']
train.drop(drop, axis=1, inplace=True)
inputs = train.values.tolist()


def evalSymbReg(individual):
    # transform the tree expression in a callable function.
    # we must give the parameters end then the tree will give us a value
    func = toolbox.compile(expr=individual)
    # using sigmoid function
    return math.fsum(
        np.round((1. - 1. / (1. + math.exp(func(*in_))))) == out for in_, out in zip(inputs, outputs)) / len(train),


toolbox.register("evaluate", evalSymbReg, points=[x / 10. for x in range(-10, 10)])
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("mate", gp.cxOnePoint)
toolbox.register("expr_mut", gp.genFull, min_=0, max_=2)
toolbox.register("mutate", gp.mutUniform, expr=toolbox.expr_mut, pset=pset)

toolbox.decorate("mate", gp.staticLimit(key=op.attrgetter("height"), max_value=17))
toolbox.decorate("mutate", gp.staticLimit(key=op.attrgetter("height"), max_value=17))

pop = toolbox.population(n=300)
hof = tools.HallOfFame(1)

stats_fit = tools.Statistics(lambda ind: ind.fitness.values)
stats_size = tools.Statistics(len)
mstats = tools.MultiStatistics(fitness=stats_fit, size=stats_size)
mstats.register("avg", np.mean)
mstats.register("std", np.std)
mstats.register("min", np.min)
mstats.register("max", np.max)

pop, log = algorithms.eaSimple(pop, toolbox, 0.5, 0.1, 40, stats=mstats,
                               halloffame=hof, verbose=True)

print(len(train))
